# 搜索接口防护方案

适用于 PHP 搜索接口的服务端防护



- **服务端防护**：最后一道保险，处理漏网之鱼

---

## 1. 空查询拦截

**目的**：阻止 `/search?q=` 空参数攻击

**代码**：
```php
if ($_SERVER['REQUEST_METHOD'] === 'GET' && isset($_GET['q']) && trim($_GET['q']) === '') {
    http_response_code(400);
    exit;
}
```

**位置**：放在搜索逻辑最前面，尽早拦截

**效果**：⭐⭐⭐ 零开销直接退出，不执行任何后续代码

---

## 2. 关键词长度限制

**目的**：防止超短/超长关键词打数据库 LIKE 查询

**代码**：
```php
$keyword = trim($_GET['q'] ?? '');
$len = mb_strlen($keyword, 'UTF-8');
if ($len < 1 || $len > 100) {
    http_response_code(400);
    exit;
}
```

**参数建议**：
- 最少1个字符（中文1个字也算1）
- 最多100个字符，防止超长字符串

**效果**：⭐⭐ 防畸形请求，减轻数据库压力

---

## 3. Referer 校验

**目的**：阻止外站直接调用搜索接口

**代码**：
```php
$referer = $_SERVER['HTTP_REFERER'] ?? '';
if (empty($referer)) {
    http_response_code(403);
    exit;
}
$refererHost = parse_url($referer, PHP_URL_HOST);
if ($refererHost !== 'example.com') {
    http_response_code(403);
    exit;
}
```

**注意**：
- 空 Referer 不放行，搜索入口都在站内，正常用户不会直接访问搜索 URL
- Referer 可被伪造，防护效果有限

**效果**：⭐⭐ 防君子不防小人，但能堵住大部分简单攻击

---

## 完整示例

```php
public function search(string $lang, int $page = 1): void
{
    if ($_SERVER['REQUEST_METHOD'] === 'GET' && isset($_GET['q']) && trim($_GET['q']) === '') {
        http_response_code(400);
        exit;
    }

    $referer = $_SERVER['HTTP_REFERER'] ?? '';
    if (empty($referer)) {
        http_response_code(403);
        exit;
    }
    $refererHost = parse_url($referer, PHP_URL_HOST);
    if ($refererHost !== 'example.com') {
        http_response_code(403);
        exit;
    }

    $keyword = trim($_GET['q'] ?? '');

    if (empty($keyword)) {
        header("Location: " . langUrl('', $lang));
        exit;
    }

    $len = mb_strlen($keyword, 'UTF-8');
    if ($len < 1 || $len > 100) {
        http_response_code(400);
        exit;
    }
    
    if ($page < 1) $page = 1;
    
    $links = $this->linkModel->search($lang, $keyword, $page, 20);
    $total = $this->linkModel->countSearch($lang, $keyword);
    $totalPages = ceil($total / 20);
    
    require __DIR__ . '/../views/home/search.php';
}
```