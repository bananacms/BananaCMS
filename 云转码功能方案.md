# BananaCMS 云转码功能开发文档

> 创建时间：2026-01-01
> 更新时间：2026-01-01
> 状态：待开发

## 一、功能概述

实现视频上传、转码切片、加密防盗的完整流程，让站长可以自建视频资源。

### 核心需求
- 上传视频文件（支持大文件分片上传）
- 自动转码为 HLS (m3u8 + ts)
- AES-128 加密，防止被下载合并
- 文件名混淆，防止按序号抓取
- 动态 Key 获取，增强安全性

---

## 二、技术方案

### 2.1 技术栈

| 组件 | 说明 | 必需 |
|------|------|------|
| FFmpeg | 视频转码核心工具 | ✅ 必须 |
| OpenSSL | AES-128 加密 | ✅ PHP 自带 |
| Resumable.js | 前端分片上传 | ✅ 推荐 |

### 2.2 HLS 加密方案

HLS 支持两种加密方式：
- **AES-128**：整段加密，使用 128 位密钥 + CBC 模式 + PKCS7 填充
- **SAMPLE-AES**：样本级加密，CPU 消耗更低（本方案暂不采用）

#### 加密流程
```
1. 生成 16 字节随机密钥 (encrypt.key)
2. 生成初始化向量 IV（可选，默认使用段序号）
3. FFmpeg 使用 key_info 文件进行加密切片
4. 播放器请求 m3u8 → 获取 key URL → 请求 key → 解密播放
```

### 2.3 防盗策略（三层防护）

#### 第一层：AES-128 加密
```bash
# FFmpeg 加密切片命令
ffmpeg -i input.mp4 \
  -c:v libx264 -c:a aac \
  -hls_time 10 \
  -hls_key_info_file key_info.txt \
  -hls_segment_filename '%08x.ts' \
  -hls_playlist_type vod \
  output.m3u8
```

key_info.txt 格式：
```
https://example.com/api/key/{video_id}?token=xxx
/path/to/encrypt.key
```

#### 第二层：文件名混淆
使用 `%08x` 格式生成十六进制文件名，避免顺序抓取：
```
00000000.ts, 00000001.ts → a7f3b2c1.ts, x9k4m8n2.ts
```

#### 第三层：动态 Key + Token 验证
```php
// Key 接口验证
public function key($videoId) {
    // 1. 验证 Referer
    $referer = $_SERVER['HTTP_REFERER'] ?? '';
    if (!str_contains($referer, SITE_URL)) {
        http_response_code(403);
        exit;
    }
    
    // 2. 验证 Token（时效性）
    $token = $_GET['token'] ?? '';
    $time = $_GET['t'] ?? 0;
    $expected = md5($videoId . $time . SECRET_KEY);
    if ($token !== $expected || time() - $time > 3600) {
        http_response_code(403);
        exit;
    }
    
    // 3. 返回 Key
    header('Content-Type: application/octet-stream');
    echo file_get_contents($keyPath);
}
```

---

## 三、开发任务清单

### 阶段一：基础架构（第1周）

#### 1.1 数据库设计
```sql
-- 转码任务表
CREATE TABLE `xpk_transcode` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `vod_id` int(10) unsigned DEFAULT 0 COMMENT '关联视频ID',
  `source_file` varchar(500) NOT NULL COMMENT '源文件路径',
  `output_dir` varchar(500) NOT NULL COMMENT '输出目录',
  `status` tinyint(1) NOT NULL DEFAULT 0 COMMENT '0待处理,1处理中,2完成,3失败',
  `progress` tinyint(3) unsigned DEFAULT 0 COMMENT '进度%',
  `duration` int(10) unsigned DEFAULT 0 COMMENT '时长(秒)',
  `resolution` varchar(20) DEFAULT '' COMMENT '分辨率',
  `encrypt_key` varchar(64) DEFAULT '' COMMENT '加密密钥(hex)',
  `m3u8_url` varchar(500) DEFAULT '' COMMENT 'm3u8地址',
  `error_msg` text COMMENT '错误信息',
  `created_at` int(10) unsigned DEFAULT 0,
  `updated_at` int(10) unsigned DEFAULT 0,
  `finished_at` int(10) unsigned DEFAULT 0,
  PRIMARY KEY (`id`),
  KEY `idx_status` (`status`),
  KEY `idx_vod` (`vod_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 分片上传临时表
CREATE TABLE `xpk_upload_chunk` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `upload_id` varchar(64) NOT NULL COMMENT '上传标识',
  `chunk_index` int(10) unsigned NOT NULL COMMENT '分片序号',
  `chunk_path` varchar(500) NOT NULL COMMENT '分片路径',
  `total_chunks` int(10) unsigned NOT NULL COMMENT '总分片数',
  `file_name` varchar(255) NOT NULL COMMENT '原文件名',
  `file_size` bigint(20) unsigned NOT NULL COMMENT '文件总大小',
  `created_at` int(10) unsigned DEFAULT 0,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_upload_chunk` (`upload_id`, `chunk_index`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 1.2 核心文件创建
- [ ] `core/Transcoder.php` - 转码器类
- [ ] `core/ChunkUpload.php` - 分片上传处理
- [ ] `models/Transcode.php` - 转码任务模型
- [ ] `controllers/admin/TranscodeController.php` - 后台控制器
- [ ] `views/admin/transcode/index.php` - 任务列表页
- [ ] `views/admin/transcode/upload.php` - 上传页面

#### 1.3 分片上传实现
```javascript
// 前端使用 Resumable.js
const r = new Resumable({
    target: '/admin.php/transcode/upload',
    chunkSize: 5 * 1024 * 1024, // 5MB
    simultaneousUploads: 3,
    testChunks: true, // 支持断点续传
    query: { _token: csrfToken }
});

r.on('fileProgress', (file) => {
    updateProgress(file.progress() * 100);
});

r.on('fileSuccess', (file, response) => {
    // 上传完成，创建转码任务
});
```

```php
// 后端分片处理
public function upload() {
    $chunkIndex = $_POST['resumableChunkNumber'] - 1;
    $totalChunks = $_POST['resumableTotalChunks'];
    $uploadId = $_POST['resumableIdentifier'];
    
    // 保存分片
    $chunkPath = RUNTIME_PATH . "chunks/{$uploadId}/{$chunkIndex}";
    move_uploaded_file($_FILES['file']['tmp_name'], $chunkPath);
    
    // 检查是否全部上传完成
    if ($this->isUploadComplete($uploadId, $totalChunks)) {
        $finalPath = $this->mergeChunks($uploadId);
        $this->createTranscodeTask($finalPath);
    }
}
```

---

### 阶段二：转码核心（第2周）

#### 2.1 转码器类实现
```php
<?php
class XpkTranscoder
{
    private string $ffmpeg = '/usr/bin/ffmpeg';
    private string $ffprobe = '/usr/bin/ffprobe';
    
    /**
     * 获取视频信息
     */
    public function getVideoInfo(string $file): array
    {
        $cmd = "{$this->ffprobe} -v quiet -print_format json -show_format -show_streams " . escapeshellarg($file);
        exec($cmd, $output);
        $info = json_decode(implode('', $output), true);
        
        return [
            'duration' => (int)($info['format']['duration'] ?? 0),
            'size' => (int)($info['format']['size'] ?? 0),
            'width' => $info['streams'][0]['width'] ?? 0,
            'height' => $info['streams'][0]['height'] ?? 0,
            'bitrate' => (int)($info['format']['bit_rate'] ?? 0),
        ];
    }
    
    /**
     * 转码为加密 HLS
     */
    public function transcodeToHLS(string $input, string $outputDir, array $options = []): array
    {
        $segmentTime = $options['segment_time'] ?? 10;
        
        // 创建输出目录
        if (!is_dir($outputDir)) {
            mkdir($outputDir, 0755, true);
        }
        
        // 生成加密密钥
        $key = random_bytes(16);
        $keyHex = bin2hex($key);
        $keyFile = $outputDir . '/encrypt.key';
        file_put_contents($keyFile, $key);
        
        // 生成 key_info 文件
        $keyUrl = $options['key_url'] ?? '/api/transcode/key';
        $keyInfo = $outputDir . '/key_info.txt';
        file_put_contents($keyInfo, "{$keyUrl}\n{$keyFile}");
        
        // 构建 FFmpeg 命令
        $cmd = "{$this->ffmpeg} -i " . escapeshellarg($input) . " ";
        $cmd .= "-c:v libx264 -preset fast -crf 23 ";
        $cmd .= "-c:a aac -b:a 128k ";
        $cmd .= "-hls_time {$segmentTime} ";
        $cmd .= "-hls_segment_filename " . escapeshellarg($outputDir . '/%08x.ts') . " ";
        $cmd .= "-hls_playlist_type vod ";
        $cmd .= "-hls_key_info_file " . escapeshellarg($keyInfo) . " ";
        $cmd .= escapeshellarg($outputDir . '/index.m3u8') . " 2>&1";
        
        exec($cmd, $output, $returnCode);
        
        // 清理 key_info 文件（安全考虑）
        unlink($keyInfo);
        
        return [
            'success' => $returnCode === 0,
            'key' => $keyHex,
            'm3u8' => $outputDir . '/index.m3u8',
            'output' => implode("\n", $output),
        ];
    }
    
    /**
     * 获取转码进度（通过日志解析）
     */
    public function getProgress(string $logFile, int $totalDuration): int
    {
        if (!file_exists($logFile)) return 0;
        
        $log = file_get_contents($logFile);
        if (preg_match('/time=(\d{2}):(\d{2}):(\d{2})/', $log, $m)) {
            $currentTime = $m[1] * 3600 + $m[2] * 60 + $m[3];
            return min(99, (int)($currentTime / $totalDuration * 100));
        }
        return 0;
    }
}
```

#### 2.2 定时任务处理
```php
<?php
// cron_transcode.php - 每分钟执行
// Crontab: * * * * * php /www/site/cron_transcode.php

require_once __DIR__ . '/config/config.php';

$db = XpkDatabase::getInstance();
$transcoder = new XpkTranscoder();

// 获取待处理任务（一次处理一个）
$task = $db->queryOne(
    "SELECT * FROM " . DB_PREFIX . "transcode WHERE status = 0 ORDER BY id LIMIT 1"
);

if (!$task) exit;

// 标记为处理中
$db->execute(
    "UPDATE " . DB_PREFIX . "transcode SET status = 1, updated_at = ? WHERE id = ?",
    [time(), $task['id']]
);

try {
    // 获取视频信息
    $info = $transcoder->getVideoInfo($task['source_file']);
    
    // 执行转码
    $result = $transcoder->transcodeToHLS($task['source_file'], $task['output_dir'], [
        'key_url' => SITE_URL . '/api/transcode/key/' . $task['id']
    ]);
    
    if ($result['success']) {
        $db->execute(
            "UPDATE " . DB_PREFIX . "transcode SET 
                status = 2, 
                progress = 100,
                duration = ?,
                resolution = ?,
                encrypt_key = ?,
                m3u8_url = ?,
                finished_at = ?,
                updated_at = ?
            WHERE id = ?",
            [
                $info['duration'],
                $info['width'] . 'x' . $info['height'],
                $result['key'],
                str_replace(ROOT_PATH, '', $result['m3u8']),
                time(),
                time(),
                $task['id']
            ]
        );
    } else {
        throw new Exception($result['output']);
    }
} catch (Exception $e) {
    $db->execute(
        "UPDATE " . DB_PREFIX . "transcode SET status = 3, error_msg = ?, updated_at = ? WHERE id = ?",
        [$e->getMessage(), time(), $task['id']]
    );
}
```

---

### 阶段三：安全加固（第3周）

#### 3.1 Key 接口实现
```php
// api.php 添加路由
case 'transcode/key':
    $controller = new ApiTranscodeController();
    $controller->key($_GET['id'] ?? 0);
    break;

// ApiTranscodeController.php
class ApiTranscodeController
{
    public function key($taskId)
    {
        // 1. 验证 Referer
        $referer = $_SERVER['HTTP_REFERER'] ?? '';
        if (!empty($referer) && !str_contains($referer, $_SERVER['HTTP_HOST'])) {
            http_response_code(403);
            exit('Forbidden');
        }
        
        // 2. 验证 Token
        $token = $_GET['token'] ?? '';
        $time = (int)($_GET['t'] ?? 0);
        
        if (empty($token) || time() - $time > 7200) {
            http_response_code(403);
            exit('Token expired');
        }
        
        $expected = md5($taskId . $time . ENCRYPT_SECRET);
        if (!hash_equals($expected, $token)) {
            http_response_code(403);
            exit('Invalid token');
        }
        
        // 3. 获取 Key
        $db = XpkDatabase::getInstance();
        $task = $db->queryOne(
            "SELECT encrypt_key, output_dir FROM " . DB_PREFIX . "transcode WHERE id = ? AND status = 2",
            [$taskId]
        );
        
        if (!$task) {
            http_response_code(404);
            exit('Not found');
        }
        
        // 4. 返回 Key（二进制）
        header('Content-Type: application/octet-stream');
        header('Cache-Control: no-cache, no-store');
        echo hex2bin($task['encrypt_key']);
    }
}
```

#### 3.2 m3u8 动态生成
```php
// 动态生成带签名的 m3u8
public function getM3u8($taskId)
{
    $task = $this->getTask($taskId);
    $m3u8Content = file_get_contents($task['output_dir'] . '/index.m3u8');
    
    // 替换 Key URL，添加时效签名
    $time = time();
    $token = md5($taskId . $time . ENCRYPT_SECRET);
    $keyUrl = SITE_URL . "/api/transcode/key/{$taskId}?t={$time}&token={$token}";
    
    $m3u8Content = preg_replace(
        '/#EXT-X-KEY:METHOD=AES-128,URI="[^"]*"/',
        '#EXT-X-KEY:METHOD=AES-128,URI="' . $keyUrl . '"',
        $m3u8Content
    );
    
    header('Content-Type: application/vnd.apple.mpegurl');
    echo $m3u8Content;
}
```

#### 3.3 Nginx 防盗链配置
```nginx
# ts 文件防盗链
location ~ \.ts$ {
    valid_referers none blocked server_names *.yourdomain.com;
    if ($invalid_referer) {
        return 403;
    }
    
    # 禁止直接下载
    add_header Content-Disposition "";
    add_header X-Content-Type-Options nosniff;
}

# 禁止直接访问 key 文件
location ~ /encrypt\.key$ {
    deny all;
}
```

---

## 四、服务器配置

### 4.1 安装 FFmpeg

**CentOS 7/8:**
```bash
# 安装 EPEL 和 RPM Fusion
yum install epel-release
yum install https://download1.rpmfusion.org/free/el/rpmfusion-free-release-7.noarch.rpm
yum install ffmpeg ffmpeg-devel
```

**Ubuntu/Debian:**
```bash
apt update
apt install ffmpeg
```

**宝塔面板:**
软件商店 → 搜索 "FFmpeg" → 安装

**验证:**
```bash
ffmpeg -version
# 确保包含 libx264, aac 编码器
ffmpeg -encoders | grep -E "libx264|aac"
```

### 4.2 PHP 配置
```ini
; /etc/php.ini 或 php-fpm.conf
max_execution_time = 0          ; 转码可能很久
memory_limit = 512M
upload_max_filesize = 5M        ; 分片大小
post_max_size = 10M
```

### 4.3 目录权限
```bash
# 创建必要目录
mkdir -p /www/site/runtime/chunks
mkdir -p /www/site/upload/transcode

# 设置权限
chown -R www:www /www/site/runtime
chown -R www:www /www/site/upload
chmod -R 755 /www/site/runtime
chmod -R 755 /www/site/upload
```

---

## 五、API 接口文档

### 5.1 分片上传

**POST** `/admin.php/transcode/upload`

| 参数 | 类型 | 说明 |
|------|------|------|
| resumableChunkNumber | int | 当前分片序号 |
| resumableTotalChunks | int | 总分片数 |
| resumableIdentifier | string | 上传标识 |
| resumableFilename | string | 文件名 |
| resumableTotalSize | int | 文件总大小 |
| file | file | 分片文件 |

**响应:**
```json
{"code": 0, "msg": "success"}
```

### 5.2 获取任务列表

**GET** `/admin.php/transcode`

**响应:**
```json
{
    "code": 0,
    "data": {
        "list": [...],
        "total": 100
    }
}
```

### 5.3 获取播放地址

**GET** `/api/transcode/play/{id}`

**响应:**
```json
{
    "code": 0,
    "data": {
        "m3u8": "https://example.com/api/transcode/m3u8/123?t=xxx&token=xxx"
    }
}
```

---

## 六、替代方案（云服务）

如果服务器配置不足或不想自建，可使用云服务：

| 服务商 | 产品 | 价格 | 特点 |
|--------|------|------|------|
| 阿里云 | 媒体处理 MPS | ~0.02元/分钟 | 国内首选 |
| 腾讯云 | 媒体处理 MPS | ~0.02元/分钟 | 微信生态 |
| 七牛云 | 智能多媒体 | ~0.015元/分钟 | 性价比高 |
| Cloudflare | Stream | $5/1000分钟 | 海外首选 |

> ⚠️ AWS Elastic Transcoder 将于 2025年11月13日停止服务，不建议使用

---

## 七、参考资料

- [FFmpeg HLS 文档](https://ffmpeg.org/ffmpeg-formats.html#hls-2)
- [HLS 协议规范 RFC 8216](https://datatracker.ietf.org/doc/html/rfc8216)
- [Resumable.js 文档](https://github.com/23/resumable.js)
- [PHP-FFmpeg-video-streaming](https://github.com/quasarstream/PHP-FFmpeg-video-streaming)
- [Bitmovin HLS AES 加密说明](https://developer.bitmovin.com/encoding/docs/understanding-hls-aes-encryption)
